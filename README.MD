# TinyCraft

## Implementation Details

### Rendering

#### Generate Surface Mesh

原始数据相当于一个超大体数据的一个数据块```chunk```（多了一个padding），需要据此生成其表面的```mesh```。
我们需要找到那些可见的面，然后生成相应的```quad```（即两个三角形）。为了简单起见，冗余存储每个三角形的顶点。
基本的思路就是遍历一次chunk的每一个体素，每个体素查询周围6个面是否被遮挡，任何一个面如果没被遮挡就生成一个```quad```
这样子算法的时间复杂度在```6*sizeof(chunk)```。
如果每个```chunk```的尺寸为```32x32x256(xzy)```，那么需要```1.5MB次```。
每个chunk需要存储一个体数据块，为了加速遍历，我们只存储非空的体素，但同时为了方便增加（删除）体素，需要将其存储到
一个链表结构中，否则线性内存的增加和删除元素代价太大（参照vector），可以只用一个unordered_map。
甚至可以在存储key-value时（key为体素在chunk内的xyz坐标，value代表体素的值），在value里存储额外信息，比如是否完全不可见。
每个Cube可以有多个纹理贴图去选择，但是如果把每个纹理都单独保存成一张图片或者说加载为一个纹理对象的话 会占用更多的资源 主要是在shader里选择纹理需要额外的信息去判断 而且选择纹理这一行为本身是有代价的 那么可以将所有Cube的纹理放到一个大的纹理图中 而在生成Cube的时候 根据其纹理贴图的类别 生成相应的不同的纹理坐标 那么在shader里进行纹理采样时就无需判断 直接使用纹理坐标得到正确的贴图